'''
перед тем как переходить к поиску весов через градиентный спуск, надо немного разобраться в самом алгоритме.
Будем делать это на примере параболы, с 1 точкой минимума. В таком случае можно просто найти точку минимума, найдя производную и прировняв ее к 0,
но в этом случая воспользуемся градиентным спуском.
Если просмотрим на локальный минимум функции, то для него есть общее математическое правило:
слева от точки минимума производная отрицательная, а с права положительная. Если выберим произвольную точку и будем
двигаться в сторону точки минимума, в случае если точка была в области положительных производных, будем ее уменьшать и на оборот в случае
если точка в области отрицательных производных (увеличивать), что бы приблизиться к точке минимума:
x(n+1) = x(n) - df(x)/dx
вообще градиент нам и показывает в какую сторону нам нужно двигаться что бы достигнуть точки минимума (df(x)/dx * i, i  - единичный вектор),
т.к. градиент направлен от точки минимума,то нам нужно двигаться в обратную сторону, в сторону антиградиента (- df(x)/dx).
Но у такой формулы есть недостаток, в случаи больших значений градиента, в ходе поиска мы можем перескакивать нужное нам значение минимума,
по этому, обычно добавляют множитель L - шаг сходимости: x(n+1) = x(n) - L * (df(x)/dx)
'''

import time
import numpy as np
import matplotlib.pyplot as plt

def f(x):
    return x*x - 5*x + 5

def df(x):
    return 2*x - 5

N = 20     # число итераций
xx = 0      # начальное значение
lmd = 0.1  # шаг сходимости

x_plt = np.arange(0, 5.0, 0.1)
f_plt = [f(x) for x in x_plt]

plt.ion()   # включение интерактивного режима отображения графиков
fig, ax = plt.subplots()    # Создание окна и осей для графика
ax.grid(True)   # отображение сетки на графике

ax.plot(x_plt, f_plt)                   # отображение параболы
point = ax.scatter(xx, f(xx), c='red')  # отображение точки красным цветом

for i in range(N):
    xx = xx - lmd*df(xx)    # изменение аргумента на текущей итерации

    point.set_offsets([xx, f(xx)])  # отображение нового положения точки

    # перерисовка графика и задержка на 20 мс
    fig.canvas.draw()
    fig.canvas.flush_events()
    time.sleep(0.02)

plt.ioff()   # выключение интерактивного режима отображения графиков

print(xx)
ax.scatter(xx, f(xx), c='blue')
plt.show()

'''
сходимость алгоритма очень зависит от параметра L - шага сходимости.
Вообще его стоит подбирать исходя из задачи (например 0.1 - 0.01 - 0.001), но можно  задавать такой формулой:
L = 1 / min(n+1 , mn) mn константа и задается в ручную, n = 0,1,2,...
Еще есть способ, можно нормализовать градиент к 1
grad f(x,y,z,...) = {df(x,y,z,...)/dx, df(x,y,z,...)/dy , df(x,y,z,...)/dz, ...}
Вычислем норму (длину вектора): |grad f(x,y,z,...)| = sqrt((df/dx)^2 + (df/dy)^2 + (df/dz)^2)
Нормировка: grad ф = grad f(x,y,z,...) / |grad f(x,y,z,...)|
Теперь значение градиента будет единичным и не будет влиять на скорость сходимости алгоритма, теперь она зависит только от L. 
Получим: x(n+1) = x(n) - L * grad f(x,y,z,...) / |grad f(x,y,z,...)|
на сходимость теперь влияет только знак градиента тоесть если:
grad f = 
 1 df(x)/dx > 0
 0 df(x)/dx = 0
-1 df(x)/dx < 0
'''

plt.ion()   # включение интерактивного режима отображения графиков
fig, ax = plt.subplots()    # Создание окна и осей для графика
ax.grid(True)   # отображение сетки на графике

ax.plot(x_plt, f_plt)                   # отображение параболы
point = ax.scatter(xx, f(xx), c='red')  # отображение точки красным цветом

#lmd = 0.1 # шаг сходимости
mn=200
for i in range(N):
    lmd = 1 / min(i+1 , mn) # будем расчитывать шаг сходимости по формуле
    xx = xx - lmd* np.sign(df(xx))    # учитываем только знак градиента

    point.set_offsets([xx, f(xx)])  # отображение нового положения точки

    # перерисовка графика и задержка на 20 мс
    fig.canvas.draw()
    fig.canvas.flush_events()
    time.sleep(0.02)

plt.ioff()   # выключение интерактивного режима отображения графиков

print(xx)
ax.scatter(xx, f(xx), c='blue')
plt.show()